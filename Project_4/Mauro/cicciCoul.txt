void evalUcoul(double *dst)
{
    double ans = 0;
    double r;
    for (int index = 0; index < Nmesh; index+=2)
    {
        // pPsi[index] at r = r0 + index*h, need to get up to this coordinate for first integral
        ans = 0;
        if (index == 0)
        {
            ans = dst[0]/r0; // realRho*r0
        }
        else
        {
            for (int i = 2; i < index+1; i++)
            {
                r = r0 + i*h;
                (i % 2) ? ans += 4*dst[i] : ans += 2*dst[i];
                //             = 4*realRho*r*r*4*M_PI
            }
            ans -= dst[2];
            ans += 1.125*(3*dst[0] + 3*dst[1] + dst[2]);
            ans /= (r0+index*h);
            ans -= dst[index]/(r0+index*h);
        }

        if (index == Nmesh - 2)
        {
            ans += dst[index]/(r0 + index*h) + dst[index + 1]/(r0 + (index+1)*h);
        }
        else
        {
            for (int i = index; i < Nmesh - 3; i++)
            {
                r = r0 + i*h;
                (i % 2) ? ans += 4*dst[i]/r : ans += 2*dst[i]/r;
            }
            ans -= dst[index]/(r0+index*h);
            ans -= dst[Nmesh-1]/(r0+(Nmesh-1)*h);

            // Simpson 3/8 rule, though with 9/8 cause at the end do *h/3 // MAYBE BELOW
            ans += 1.125*(dst[Nmesh-1]/(r0+(Nmesh-1)*h) + 3*dst[Nmesh-2]/(r0+(Nmesh-2)*h) + 3*dst[Nmesh-3]/(r0+(Nmesh-3)*h) + dst[Nmesh-4]/(r0+(Nmesh-4)*h));

        }

        ans *= h/3;
        Ucoul[index] = ans;
    }

    for (int index = 1; index < Nmesh; index+=2)
    {
        ans = 0;
        for (int i = 0; i < index+1; i++) // Use fact that actually 0-th point is zero
        {
            r = r0 + i*h;
            (i % 2) ? ans += 2*dst[i] : ans += 4*dst[i];
        }
        ans /= (r0+index*h);
        ans -= dst[index]/(r0+index*h); // Same as moving this one line above and add r^2 instead of r only

        if (index == Nmesh - 1)
        {
            ans += 3*dst[Nmesh-1]/(r0+(Nmesh-1)*h);
        }
        else
        {
            for (int i = index; i < Nmesh; i++) // Simpson missing last 3 points
            {
                r = r0 + i*h;
                (i % 2) ? ans += 2*dst[i]/r : ans += 4*dst[i]/r;
            }
            ans -= dst[index]/(r0+index*h);
            ans -= dst[Nmesh]/(r0+Nmesh*h);
        }

        ans *= h/3;
        Ucoul[index] = ans;
    }
}